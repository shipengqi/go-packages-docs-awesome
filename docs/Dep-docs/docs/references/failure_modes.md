# 故障模式

与所有复杂的面向网络的软件一样，DEP具有已知的故障模式.这些通常分为两类:I/O和逻辑.I/O错误源于对与网络或本地磁盘交互的系统调用的意外响应.当DEP在包管理问题域内遇到问题时，会发生逻辑故障.

## 输入输出错误

dep从网络读取，并读写到磁盘，因此会受到此类活动可能出现的所有典型错误的影响.

完整的磁盘、失败的磁盘、缺乏权限、网络分区、防火墙等.然而，有三类I/O错误值得特别处理:

-   网络故障
-   局部缓存状态不好
-   `vendor`写入错误

一般来说，这些问题不是我们可以在dep中合理编程的.因此，它们不能被认为是需要我们修复的bug.幸运的是，这些问题大多有直接的补救措施.

### 网络故障

> **修复TL;DR:**大多数网络问题都是短暂的，即使它们可能持续几分钟，并且可以通过重新运行相同的命令来解决.在尝试更具侵入性的解决方案之前，请先尝试一下.

DEP在几个不同的点与网络对话.这些依赖于源(VCS)类型和本地磁盘状态有所不同，但这一操作列表通常具有启发性:

-   当DEP不能[静态演绎](deduction.md#static-deduction)导入路径的源根，它发出一个`go-get`HTTP元数据请求到从导入路径构建的URL.
-   检索源的可用版本列表(思考)`git ls-remote`必然需要网络活动.
-   最初下载(按GIT术语)`git clone`)到本地高速缓存的上游源也必然需要网络活动.
-   更新本地缓存(以GIT术语)`git fetch`)来自上游来源的最新变化.
-   写下代码树`vendor`通常是从本地缓存完成的，但在某些情况下，可以从远程源上飞取TARBARE.

实际上，你可能会观察到的网络故障偏向列表中的早期项目，仅仅是因为这些操作往往先发生:通常看不到更新失败与版本列表失败一样多，因为它们通常具有相同的根本原因(源主机是DOW).N，网络分区等)，但版本列表请求首先发生在大多数路径上.

#### 持久性网络故障

虽然大多数网络故障是短暂的，但有三个定义良好的情况下，它们更持久:

-   **源驻留的网络从用户的位置是永久不可到达的:**在实践中，这通常意味着两件事之一:你忘记登录到你公司的VPN，或者你落后了.[gfw the](https://en.wikipedia.org/wiki/Great_Firewall).在后者的房屋，setting the*事实上*HTTP代理服务器环境变量，标准[`http.ProxyFromEnvironment()`](https://golang.org/pkg/net/http/#ProxyFromEnvironment)respects将原因dep' S`go-get`HTTP请求的元数据，作为阱和bzr Hg，As Git子命令，utilize to the代理.

    -   确切的说因为是修复is also the same when the custom`go-get`元数据服务的HTTP similarly unreachable is for a源.the messages会失败，不管一个人多，看起来像[更广泛的演绎](#deduction-failures).

-   **permanently has been the source:moved消去.**这些是[左垫](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)虽然没有说明，that[在GitHub redirects交通renames automatically](https://help.github.com/articles/renaming-a-repository/)减轻重命名问题.但是，如果移除上游源，dep将无法继续进行，直到为导入路径建立了新的上游源.为此目的:

    -   如果在本地缓存或GOPATH中仍然有源存储库的副本，请考虑将其上载到新位置(例如，分叉)并使用[`source`](Gopkg.toml.md#source)规则指向叉.
    -   如果本地没有一个完整的存储库，则提取当前的代码.`vendor`将目录导入新的存储库并将其推送到A.(注意:这可能有许可证的含义).
    -   如果你在本地没有代码的实例，那么可以做的就很少——代码已经不见了，你将需要重构项目.

    dep的未来版本将能够在创建新的上游/分叉源之前更好地处理一个过渡时期，或者仅仅生活在一个给定代码树只存在于项目中的世界中`vendor`目录.

-   **用户缺少与源交互的必要凭据:**见[配置凭证常见问题解答](FAQ.md#how-do-i-get-dep-to-authenticate-to-a-git-repo).

准确的错误文本将根据运行中的操作、源dep尝试与哪种类型的源dep通信以及实际网络问题发生而有所不同.错误文本可能并不总是立即明确你要处理的这些内容的组合，但是对于持久性问题，它至少应该减少搜索空间.

#### 吊挂

> **修复TL;DR:**挂起几乎总是网络拥塞，或者纯粹的网络数据量来获取.等待，或取消并重试`-v`试图获得更多的上下文.

几乎任何DEP命令运行的情况下`-v`挂机超过十分钟，最终将是一个错误.然而，对于明显的dep挂起最常见的解释实际上是正常的行为:因为dep的操作要求它保留自己的上游源拷贝，隐藏在[本地缓存](glossary.md#local-cache)对于项目，特别是大型项目，DEP的第一次运行可能需要很长的时间来填充缓存.

唯一已知的dep可能无限期挂起的情况是，如果它调用的一个底层VCS二进制文件提示输入某种内容.通常这意味着凭据(虽然不总是-确保接受远程主机的SSH密钥到你已知的主机!)而DEP的正常假设是通过环境机制提供必要的凭证.[配置文件或守护程序](FAQ.md#how-do-i-get-dep-to-authenticate-to-a-git-repo)这个假设对于DEP的并发网络活动是必要的.如果你的用例绝对不能支持使用任何这样的环境缓存机制，[请在这个问题上斟酌一下.](https://github.com/golang/dep/issues/1476).

遗憾的是，直到DEP[提高其正在进行的I/O操作的可观测性](<>)它不能准确地向用户报告在任何给定的时刻实际正在进行的操作.这使得很难与其他挂起区分——凭证提示、防火墙导致的长网络超时、面临分组丢失时TCP的迟缓等等.

### 局部缓存状态不好

> **修复TL;DR:**删除本地缓存DIR:`rm -rf $GOPATH/pkg/dep/sources`.

有可能的部分[本地缓存](glossary.md#local-cache)由DEP维持，进入一个糟糕的状态.这主要发生在DEP过程被强制终止时(例如CTRL- C).例如，这可以终止`git`命令绕过，在磁盘上留下坏的状态.根据DEP的定义，A[脏工作拷贝](<>)是坏状态.

由于本地缓存状态不佳而引起的错误消息通常不包括完整路径，因此可能不会立即发现问题源于本地缓存.如果不包括完整路径，那么最好的提示就是这些错误看起来像本地VCS错误，但它们不在你自己的项目的文件上.

然而，在大多数情况下，**DEP从坏的本地缓存状态问题中自动发现和恢复**反弹到一个好的状态，因为它引导每个命令执行.如果你确实遇到一个看起来是本地缓存问题，dep不会自动从中恢复，那么修复通常是抛出缓存，`rm -rf $GOPATH/pkg/dep/sources`DEP将在下一次运行中自动重新填充它.但是，如果你有时间，请保存本地缓存DIR并作为bug报告它!

没有已知的情况下，在正常操作过程中，DEP可以不可修复地破坏它自己的本地缓存.任何这样的情况都会被认为是DEP中的一个关键错误，你应该报告它!如果你认为你遇到过这样的情况，它应该具有以下特点:

-   你所看到的错误消息与下载源中的某种磁盘状态错误一致.`$GOPATH/pkg/dep/sources`
-   你可以在`$GOPATH/pkg/dep/sources`由上述误差提出
-   删除本地缓存DIR并运行相同的命令后，同样的错误会再次出现，**没有**过早终止项目(例如通过CTRL—C)

### `vendor`写入错误

DEP在试图写出错误时可能会遇到错误.`vendor`目录本身(任何这样的错误都会导致完全回滚;不会对磁盘造成任何更改).为了找出问题所在，知道这是人口流动的趋势.`vendor`:

1.  在系统临时目录中分配一个新的临时目录.
2.  重命名现有`vendor`目录到`vendor.orig`. 如果可能的话，在当前项目的根目录中执行此操作;如果没有，将其重命名并移动到Tundir.
3.  创建新的`vendor`在Tundir中的目录，同时将其填充到所有被命名为`Gopkg.lock`.
4.  移动新的`vendor`在当前项目的根目录中放入目录.
5.  删除旧的`vendor`目录.

注:此流程将变得更具针对性[供应商验证](<>)允许DEP识别和瞄准当前项目中的子集`vendor`这需要改变.

这一类已知的问题包括:

-   临时目录中的空间不足会导致错误，引发回滚.但是，因为回滚过程清理了到目前为止编写的文件，所以临时分区在dep退出之后实际上不会满，这可能会产生误导.
-   试图[重新]移动原件`vendor`如果目录中的任何文件在某些编辑器/某些OS(特别是Windows)上"打开"，则目录可能出现权限错误.[这是个问题](<>).

## 逻辑故障

逻辑故障包含DEP的逻辑问题解决域内可能发生的一切.

这些失败中的一些可能和形式错误一样简单，也很容易解决.不幸的是，其他人可能需要分叉和修改上游项目——尽管这种情况非常罕见.

### 演绎失败

导入路径演绎，详见[演绎参考](deduction.md)具有静态和动态两个阶段.当这两个阶段都不能确定给定导入路径的源根时，它被认为是演绎失败.演绎失败都包含这个关键错误文本:

```bash
...unable to deduce repository and source type for "<bad path>"...
```

*注:有[对于小的子集，更多的错误消息](#malformed-import-paths)其中进口路径似乎是可推断的，但不知何故是畸形的.*

当在给定的导入路径上发生演绎失败时，最接近的原因将是以下五种情形之一(从最有可能到最不可能):

-   进口路径永远不可推论.
-   **动态演绎失败:**
    -   导入路径一次是动态推断的，元数据的服务是上升的，但它是不可到达的.
    -   导入路径一度是动态推断的，但是它的元数据服务被降低了.
-   **静态规则更改:**
    -   运行版本的dep不能静态地推导导入路径，但是更新版本的dep添加了可以静态地推导导入路径的规则.
    -   导入路径曾经是静态推断的，但是DEP的运行版本已经停止了对它的支持.

在所有这些情况下，你最后的追索将是增加一个[`source`](Gopkg.toml.md#source)指令来解决问题.然而，这些指令是易碎的，只应在其他选项用完时使用;[这个问题解决了.](https://github.com/golang/dep/issues/860)甚至`source`可能无法帮助.

#### 不可推断的路径

> **修复TL;DR:**你打错了，把它修好.如果不是，你可能需要一个`source`但不要吝啬.

推断失败的最有可能的原因是轻微的用户错误.具体地说，用户是*现在的*用户(你)，并且错误是在当前(你的)项目中有一个错误的导入路径.问题可能在你的身上`Gopkg.toml`或者一个导入，但是错误消息应该直接指出问题，并且解决方案通常是显而易见的，例如，"gihtub".

来自当前项目的输入的验证是在dep中快速且预先进行的，因此这些错误将倾向于立即出现.在这种快速验证和项目通常无法编译的事实之间，或者至少不是这样.`go get`由于这些错误，他们很容易被提前抓到.这就是为什么真正难以置信的路径在攻击自己的项目时主要表现为临时事故——你必须修复它们才能继续前进.

然而，这种不可信性是直接和困难的阻碍，导致这是向dep迁移的症结所在.

-   其他几个GO依赖性管理工具允许指定任意的VCS/源URL，并且[但是支持通过`source`DEP仍悬而未决](https://github.com/golang/dep/issues/860).
-   GITHUB企业只有实现`go-get`HTTP元数据正确地存储库的根包.在实践中，这使得所有导入路径指向不可推断的，并且`source`没有前面提到的改进也不能帮助.

如果问题导入路径在当前项目中，但是问题不是明显的打字错误，那么你可能遇到动态故障，或者可能需要检查[演绎参考](deduction.md)了解什么是可推断的进口路径.

#### 动态推理失败

大多数动态演绎失败要么是短暂的网络问题，要么是服务可用性问题，并且会通过重新运行前面的命令而消失.总是先试试看.

如果这个问题仍然存在，并且你肯定进口路径应该是可推断的，网络问题是检查的第一个罪魁祸首.当元数据服务不可到达时，典型的原因(VPN、防火墙)和补救是相同的.[当源本身不可到达时](#persistent-network-failures).

下一种可能性是永久消失的元数据服务.尽管网络错误仍然相当常见，但是很少遇到指向已失效的公共元数据服务的导入路径.考虑一下:一个导入路径可以让整个项目变得不可取和/或不可编译，并且这两个状态都不是流行项目可以长期使用的状态.因此，由于大多数(公共Go生态系统)依赖关系都依赖于更流行的项目，所以只要你还依赖于更流行的项目，就不大可能遇到这种情况.

当然，已经失效*私有的*元数据服务可能更为常见，因为它们受到完全不同的激励.

如果你认为你遇到了一个已失效的元数据服务，请尝试直接探测导入路径的域部分，以查看是否存在HTTP服务器.如果不是，你只能强迫`source`-假设你知道应该使用什么源URL.如果没有，你可能需要重构你的代码(如果问题在你的项目)，选择一个不同的版本的问题依赖性下降的问题，或完全依赖;有时，你不得不摆脱死代码.

#### 静态规则变化

> **修复TL;DR:**确保你有最新版本的DeP.

静态规则更改不太可能是推理失败的原因.

似是而非，DEP将在未来添加新的静态演绎规则.这是可能的，如果你有一个旧版本的DEP，和你合作或将使用新版本的DEP有代码，那么他们的代码可能会利用新的导入路径模式，你的部门不知道.但是，很少有静态的规则可能会增加了DEP在其一生中，获取他们的问题就是更新一次.

最后的场景——DEP停止支持静态演绎模式包括清晰、完整，但根本不应该发生的.即使一个托管服务由静态规则今天被关闭，DEP将保留现有的静态规则;如果托管代码被转移到别处，然后DEP会尝试自动完成映射.如果没有这样的映射的话，那么DEP仍然承认基本的主机模式，但可以依靠使用畸形的导入路径错误的下一个话题——翔实拒绝从主机新的进口.

#### 畸形进口路径

在很大程度上，静态("它是我们知道的少数主机之一吗?")和动态("只要做元数据服务告诉我们做什么")扣除是单次检查.然而，这两种情况都可以执行一些次要的验证:

-   In static deduction， the rules are necessarily specific to each host， but most enforce allowable characters and schemes in URLs that are known to be required by the underlying host.
-   In dynamic deduction， responses from the metadata service are minimally validated to ensure that the source type and scheme are all supported， and that the URL contains valid characters.

### 解决故障

什么时候?`dep ensure`或`dep init`用一个错误消息退出，看起来像这样:

```bash
$ dep init
init failed: unable to solve the dependency graph: Solving failure: No versions of github.com/foo/bar met constraints:
	v1.0.1: Could not introduce github.com/foo/bar@v1.13.1， as its subpackage github.com/foo/bar/foo is missing. (Package is required by (root).)
	v1.0.0: Could not introduce github.com/foo/bar@v1.13.0， as...
	v0.1.0: (another error)
	master: (another error)
```

*注意:其他三种硬故障类型有时可以报告为以下列表中各个版本的错误.这主要是因为DEP需要一个[错误处理的彻底重构](https://github.com/golang/dep/issues/288).*

这意味着求解器无法为满足由求解器执行的所有规则的所有依赖项找到版本组合.值得注意的是，因为DEP提供了一个很大的原因列表，说明每个版本失败的原因.*并不意味着*你必须解决每一个问题!这只是DEP告诉你为什么它最终不能在解决方案中使用这些版本中的每一个.

这些规则，以及未能满足它们的具体补救措施，在章节中详细描述.[求解不变量](the-solver.md#solving-invariants). 本节是关于解决一般故障发生时所采取的步骤.但是，为了设置上下文，这里有一个总结:

-   **`[[constraint]]`冲突:**当依赖图中的项目在什么方面不一致时[版本](Gopkg.toml.md#version-rules)可以接受的项目，或在哪里[来源](Gopkg.toml.md#source)它来自.
    -   修复通常会改变`[[constraint]]`或添加`[[override]]`但是真正的冲突可能需要分叉和黑客代码.
-   **包有效性失效:**当一个进口的包裹显然不能建造的时候.
    -   除了"停止导入"之外，这里通常没有太多的补救措施，因为它指示了某个版本的损坏.
-   **导入注释失败:**当用于处理包的导入路径与[导入评论](https://golang.org/cmd/go/#hdr-Import_path_checking)包用来指定它应该如何导入.
    -   补救是使用指定的导入路径，而不是使用任何一个.
-   **仅发生导入变更失败:**当两个相等的情况下，除了案例导入存在于同一个构建中.
    -   补救是选择一个案例变体在整个项目中使用，然后手动更新depgraph中的所有项目以使用新外壳.

让我们把解决失败的过程分解成一系列步骤:

1.  首先，查看失败版本列表，查找适合你的依赖关系的版本(或者看起来可以修复的故障)，然后尝试解决这个问题.通常，你会看到在整个版本列表中重复出现单个故障，这非常清楚需要解决什么问题.
2.  采取针对失败的补救措施.
3.  重新运行运行失败的相同命令.有三种可能的结果:
    1.  成功!
    2.  你的修复无效，同样的故障再次发生.要么重新检查你的修复(步骤2)，要么寻找新的故障修复(步骤1).
    3.  你的解决办法是有效的，但出现了一些新的失败.返回具有新故障列表的步骤1.
